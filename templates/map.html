<div id="dublin_bike_map_id" class="h-screen w-screen"></div>
<script type="module">
	const importGoogleMapsLibraries = async () => {
		const {Map} = await google.maps.importLibrary('maps');
		const {AdvancedMarkerElement, PinElement} = await google.maps.importLibrary(
			'marker'
		);
		const {Autocomplete} = await google.maps.importLibrary('places');
		return {Map, AdvancedMarkerElement, PinElement, Autocomplete};
	};

	const {Map, AdvancedMarkerElement, PinElement, Autocomplete} =
		await importGoogleMapsLibraries();

	const mapSettings = {
		zoom: 14,
		center: {lat: 53.347, lng: -6.27},
		mapTypeControl: false,
		streetViewControl: false,
		ClickableIcons: false,
		zoomControlOptions: {
			style: google.maps.ZoomControlStyle.SMALL,
			position: google.maps.ControlPosition.LEFT_BOTTOM,
		},
		mapId: 'dublin_bike_map_id',
	};

	const fetchProcessedStations = async () => {
		const response = await fetch('/stations');
		const stations = await response.json();
		return stations;
	};

	function createInfoWindow(station, content) {
		return new google.maps.InfoWindow({
			content: content,
			ariaLabel: `Bike Stand ${station.id.toString()}`,
		});
	}

	function createAdvancedMarker(map, pin, station) {
		return new AdvancedMarkerElement({
			map: map,
			position: {lat: station.lat, lng: station.lng},
			title: 'not selected',
			content: pin.element,
			gmpClickable: true,
		});
	}

	function createPin(station, pinColors) {
		const div = document.createElement('div');
		div.className = 'font-bold';
		div.style.fontSize = '14px';
		div.textContent = station.available_bikes.toString();

		return new PinElement({
			background: pinColors.background,
			borderColor: pinColors.border,
			glyphColor: pinColors.border,
			glyph: div,
		});
	}

	let stationDict = {};
	let tripDisplayed = false;
	let leftSideBarOpen = false;

	function selectPin(selectedMarker, selectedPin, selectedInfo) {
		if (selectedMarker.title != 'selected') {
			//unselect all other pins;
			for (let id in stationDict) {
				let pin = stationDict[id]['stationPin'];
				let marker = stationDict[id]['stationMarker'];
				let infoWindow = stationDict[id]['stationInfoWindow'];
				let tr_back = pin.background.slice(0, 18) + ', 0.4)';
				let tr_bord = pin.borderColor.slice(0, 18) + ', 0.4)';
				let tr_glyph = pin.borderColor.slice(0, 18) + ', 0.2)';
				pin.background = tr_back;
				pin.borderColor = tr_bord;
				pin.glyphColor = tr_glyph;
				pin.scale = 1;
				marker.zIndex = 1;
				marker.title = 'not selected';
				infoWindow.close();
			}
			let sel_back = selectedPin.background.slice(0, 18) + ', 1)';
			let sel_bord = selectedPin.borderColor.slice(0, 18) + ', 1)';
			selectedPin.background = sel_back;
			selectedPin.borderColor = sel_bord;
			selectedPin.glyphColor = sel_bord;
			selectedPin.scale = 1.3;
			selectedMarker.zIndex = 2;
			selectedMarker.title = 'selected';
			selectedInfo.open(map, selectedMarker);
		} else {
			showAllPins();
		}

		//event handler for closing pins when clicking on map
		map.addListener('click', function () {
			// Deselect all pins and close info windows
			for (let id in stationDict) {
				let pin = stationDict[id]['stationPin'];
				let marker = stationDict[id]['stationMarker'];
				let infoWindow = stationDict[id]['stationInfoWindow'];
				let back = pin.background.slice(0, 18) + ', 1)';
				let bord = pin.borderColor.slice(0, 18) + ', 1)';
				pin.background = back;
				pin.borderColor = bord;
				pin.glyphColor = bord;
				pin.scale = 1;
				marker.zIndex = 1;
				marker.title = 'not selected';
				infoWindow.close();
			}
			closeRightSidebar();
			selMarker = null;
		});
	}
	window.selectPin = selectPin;

	function showAllPins() {
		for (let id in stationDict) {
			let pin = stationDict[id]['stationPin'];
			let marker = stationDict[id]['stationMarker'];
			let infoWindow = stationDict[id]['stationInfoWindow'];
			let back = pin.background.slice(0, 18) + ', 1)';
			let bord = pin.borderColor.slice(0, 18) + ', 1)';
			pin.background = back;
			pin.borderColor = bord;
			pin.glyphColor = bord;
			pin.scale = 1;
			marker.zIndex = 1;
			marker.title = 'not selected';
			infoWindow.close();
		}
		closeRightSidebar();
	}

	const mapElement = document.getElementById('dublin_bike_map_id');
	const map = new Map(mapElement, mapSettings);
	let directionsService = new google.maps.DirectionsService();
	let directionsRenderer = new google.maps.DirectionsRenderer({
		suppressMarkers: true,
	});
	directionsRenderer.setMap(map);

	let selMarker = null;
	// Fetch and process the stations data
	fetchProcessedStations().then((stations) => {
		stations.forEach((station) => {
			// Assuming the Flask API returns pin colors and other necessary information
			const pin = createPin(station, station.pin_colors);
			const infoWindow = createInfoWindow(station, station.info_html);
			const marker = createAdvancedMarker(map, pin, station);
			marker.title = 'not selected';
			stationDict[station.id] = {
				stationMarker: marker,
				stationPin: pin,
				stationInfoWindow: infoWindow,
				lat: station.lat,
				lng: station.lng,
				av_bikes: station.available_bikes,
				av_stands: station.available_stands,
				name: station.name,
				id: station.id,
			};
			// Add the marker to the map
			marker.addListener('click', () => {
				if (selMarker === marker) {
					// If the clicked marker is already selected, unselect it and close the right sidebar
					selectPin(marker, pin, infoWindow, true);
					closeRightSidebar();
					selMarker = null;
				} else {
					selectPin(marker, pin, infoWindow, false);
					openRightSidebar(station.id);
					selMarker = marker;
				}
				event.stopPropagation();
			});
		});
		updateSearchBar();
	});

	const center = {lat: 53.347, lng: -6.27};
	// Create a bounding box with sides ~10km away from the center point
	const defaultBounds = {
		north: center.lat + 0.1,
		south: center.lat - 0.1,
		east: center.lng + 0.1,
		west: center.lng - 0.1,
	};
	const options = {
		bounds: defaultBounds,
		strictBounds: true,
	};

	const startPoint = new Autocomplete(
		document.getElementById('startPoint'),
		options
	);

	startPoint.addListener('place_changed', () => {
		setStartPlace(startPoint.getPlace());
	});

	const endPoint = new Autocomplete(
		document.getElementById('endPoint'),
		options
	);

	endPoint.addListener('place_changed', () => {
		setEndPlace(endPoint.getPlace());
	});

	function setDirection(
		startLatLng,
		endLatLng,
		waypts,
		wayptPositions,
		startMarkerNum,
		endMarkerNum
	) {
		directionsService.route(
			{
				origin: startLatLng,
				destination: endLatLng,
				waypoints: waypts,
				optimizeWaypoints: false,
				travelMode: google.maps.TravelMode.WALKING,
			},
			(response, status) => {
				if (status === 'OK') {
					directionsRenderer.setDirections(response);
					directionServiceMarkers(
						startLatLng,
						endLatLng,
						wayptPositions[0],
						wayptPositions[1],
						startMarkerNum,
						endMarkerNum
					);
				} else {
					window.alert('Directions request failed due to ' + status);
				}
			}
		);
	}

	//pin elements for markers below
	const waypt1Pin = new PinElement({
		background: '#9cf6f7',
		borderColor: '#0f6a6b',
		glyphColor: '#0f6a6b',
		glyph: '0',
		scale: 1.3,
	});
	const waypt2Pin = new PinElement({
		background: '#9cf6f7',
		borderColor: '#0f6a6b',
		glyphColor: '#0f6a6b',
		glyph: '0',
		scale: 1.3,
	});
	//start and end markers for trips
	const startM = new AdvancedMarkerElement({
		map: null,
		position: null,
	});
	const endM = new AdvancedMarkerElement({
		map: null,
		position: null,
	});
	const waypt1 = new AdvancedMarkerElement({
		map: null,
		position: null,
		content: waypt1Pin.element,
	});
	const waypt2 = new AdvancedMarkerElement({
		map: null,
		position: null,
		content: waypt2Pin.element,
	});

	function directionServiceMarkers(
		start,
		end,
		w1,
		w2,
		startMarkerNum,
		endMarkerNum
	) {
		startM.setMap(map);
		endM.setMap(map);
		startM.position = start;
		endM.position = end;
		if (startMarkerNum != null) {
			waypt1.setMap(map);
			waypt2.setMap(map);
			waypt1.position = w1;
			waypt2.position = w2;
			waypt1Pin.glyph = Math.round(startMarkerNum).toString();
			waypt2Pin.glyph = Math.round(endMarkerNum).toString();
		} else {
			waypt1.setMap(null);
			waypt2.setMap(null);
		}
	}

	function callDirections(
		closeIDStart,
		closeIDEnd,
		startMarkerNum,
		endMarkerNum
	) {
		let startLat = startPlace.geometry.location.lat();
		let startLng = startPlace.geometry.location.lng();
		let startLatLng = new google.maps.LatLng(startLat, startLng);

		let endLat = endPlace.geometry.location.lat();
		let endLng = endPlace.geometry.location.lng();
		let endLatLng = new google.maps.LatLng(endLat, endLng);

		let stationStart = stationDict[closeIDStart];
		let stationEnd = stationDict[closeIDEnd];

		let all = false;
		if (startMarkerNum != null) {
			all = true;
		}

		showAllPins();
		hideMarkers(stationStart, stationEnd, all);

		let StationOnelatLng = new google.maps.LatLng(
			stationStart['lat'],
			stationStart['lng']
		);
		let StationTwolatLng = new google.maps.LatLng(
			stationEnd['lat'],
			stationEnd['lng']
		);

		const waypts = [];
		const wayptPosition = [StationOnelatLng, StationTwolatLng];

		waypts.push({
			location: StationOnelatLng,
			stopover: true,
		});
		waypts.push({
			location: StationTwolatLng,
			stopover: true,
		});
		directionsRenderer.setMap(map);
		setDirection(
			startLatLng,
			endLatLng,
			waypts,
			wayptPosition,
			startMarkerNum,
			endMarkerNum
		);
		tripDisplayed = true;
	}
	window.callDirections = callDirections;

	function hideMarkers(marker1, marker2, all) {
		for (let id in stationDict) {
			if (!all && (stationDict[id] == marker1 || stationDict[id] == marker2)) {
				stationDict[id]['stationMarker'].setMap(map);
				continue;
			}
			stationDict[id]['stationMarker'].setMap(null);
		}
	}

	function leftSideBar() {
		if (leftSideBarOpen) {
			map.setCenter({lat: 53.347, lng: -6.27});
			if (tripDisplayed) {
				resetMap();
				tripDisplayed = false;
			}
		} else {
			map.setCenter({lat: 53.347, lng: -6.25});
		}
		leftSideBarOpen = !leftSideBarOpen;
	}
	window.leftSideBar = leftSideBar;

	function resetMap() {
		directionsRenderer.setMap(null);
		startM.setMap(null);
		endM.setMap(null);
		waypt1.setMap(null);
		waypt2.setMap(null);
		map.setZoom(14);
		map.setCenter({lat: 53.347, lng: -6.27});
		for (let id in stationDict) {
			stationDict[id]['stationMarker'].setMap(map);
		}
		resetLeftSideBar();
	}

	function getStationDict() {
		return stationDict;
	}
	window.getStationDict = getStationDict;
</script>
